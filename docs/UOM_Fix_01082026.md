# FilaOps UOM Standardization - Complete Implementation Plan

## Document Purpose

This document provides a complete implementation plan for standardizing Unit of Measure (UOM) handling in FilaOps. It is intended for implementation by an AI coding assistant (VS Code Claude) and includes full context, logic explanations, and step-by-step instructions.

## Problem Statement

FilaOps has persistent UOM-related bugs causing incorrect inventory quantities and cost calculations. The root causes are:

Scattered UOM logic - Conversion factors and material detection are duplicated across 6+ files
Missing purchase_factor - Materials created via material_service.py don't set purchase_factor, causing PO receiving to guess conversions
Inconsistent material detection - Some code checks material_type_id, other code checks item_type, leading to missed cases
No single source of truth - When a value needs to change, multiple files must be updated

Solution Architecture
Core Principle: Single Source of Truth
All UOM configuration for materials will live in ONE file: backend/app/core/uom_config.py
Every other file that needs UOM information will import from this file. No more scattered constants.
Key Design Decisions
DecisionRationaleStorage unit = Grams (G)Precision for 3D printing consumption trackingPurchase unit = Kilograms (KG)How vendors sell filamentPurchase factor = 10001 KG = 1000 GCost stored per KGIndustry standard, matches vendor pricingNew item_type='material'Explicit identification without relying on SKU prefixes
Detection Priority (Most Specific to Least)
When determining if an item is a material:

item_type == 'material' (explicit, new way)
item_type == 'supply' AND material_type_id IS NOT NULL (legacy filaments)
Category is filament category (category-based detection)
SKU starts with MAT- or FIL- (legacy SKU-based detection)

Current File Inventory
These files contain UOM-related code that will be modified:
FileCurrent StateChanges Neededbackend/app/core/uom_config.pyDoes not existCREATE - Central configbackend/app/services/uom_service.pyGood, has conversionsMinor - Import centralized configbackend/app/services/product_uom_service.pyMissing purchase_factorUPDATE - Use centralized configbackend/app/services/inventory_helpers.pyOnly checks material_type_idUPDATE - Add item_type checkbackend/app/services/material_service.pyMissing purchase_factorUPDATE - Use centralized configbackend/app/api/v1/endpoints/items.pyDuplicated UOM dictUPDATE - Import from uom_servicebackend/app/api/v1/endpoints/purchase_orders.pyHardcoded conversionsUPDATE - Use centralized configbackend/app/schemas/item.pyMissing MATERIAL enumUPDATE - Add enum valuebackend/tests/factories.pyWrong defaults for materialsUPDATE - Use centralized configfrontend/src/lib/uom.jsDuplicated (acceptable)No change neededfrontend/src/components/BOMEditor.jsxWrong default unit logicUPDATE - Fix material detectionfrontend/src/components/ItemForm.jsxMissing material typeUPDATE - Add material optionfrontend/src/components/ItemWizard.jsxMissing material typeUPDATE - Add material optionfrontend/src/pages/admin/AdminItems.jsxMissing material filterUPDATE - Add material option

Implementation Phases
Phase 0: Create Central Configuration (Foundation)
This phase creates the single source of truth. All subsequent phases depend on it.
0.1 Create backend/app/core/uom_config.py
python"""
UOM Configuration - Single Source of Truth

This module defines ALL UOM-related constants and logic for materials.
Every other file that needs UOM information MUST import from here.

DO NOT duplicate these values elsewhere. If you need to change material UOM
behavior, change it HERE and it will propagate everywhere.

RULES FOR MATERIALS (Filament):

- Storage unit: G (grams) - for precision tracking of consumption
- Purchase unit: KG (kilograms) - how vendors sell filament
- Purchase factor: 1000 - conversion from KG to G (1 KG = 1000 G)
- Cost reference: KG - costs (standard_cost, last_cost) are stored as $/KG
- is_raw_material: True - materials are consumed in production

COST CALCULATION EXAMPLE:

- Filament purchased at $20/KG
- Inventory shows 500 G on hand
- Inventory value = 500 G × ($20/KG ÷ 1000) = 500 × $0.02 = $10.00
"""
from decimal import Decimal
from typing import NamedTuple, Optional, List

class UOMConfig(NamedTuple):
    """Configuration for a product's unit of measure settings."""
    unit: str                    # Storage/consumption unit (G for materials)
    purchase_uom: str            # How vendors sell it (KG for materials)
    purchase_factor: Decimal     # Conversion: purchase_uom -> unit (1000 for KG->G)
    is_raw_material: bool        # Whether this is consumed in production
    cost_reference_unit: str     # What unit costs are stored per (KG for materials)

# =============================================================================

# MATERIAL UOM CONFIGURATION - THE SINGLE SOURCE OF TRUTH

# =============================================================================

MATERIAL_UOM = UOMConfig(
    unit="G",                           # Store and consume in grams
    purchase_uom="KG",                  # Buy in kilograms
    purchase_factor=Decimal("1000"),    # 1 KG = 1000 G
    is_raw_material=True,               # Consumed in production
    cost_reference_unit="KG"            # Costs are $/KG
)

DEFAULT_UOM = UOMConfig(
    unit="EA",                          # Store in each
    purchase_uom="EA",                  # Buy in each
    purchase_factor=Decimal("1"),       # No conversion
    is_raw_material=False,              # Not a raw material
    cost_reference_unit="EA"            # Costs are $/EA
)

# =============================================================================

# MATERIAL DETECTION FUNCTIONS

# =============================================================================

def is_material_item_type(item_type: Optional[str]) -> bool:
    """
    Check if item_type indicates a material product.

    Handles both enum values and plain strings.
    
    Args:
        item_type: The item_type value (string or enum)
        
    Returns:
        True if item_type is 'material'
    """
    if not item_type:
        return False
    # Handle both enum and string values
    item_type_str = item_type.value if hasattr(item_type, 'value') else str(item_type)
    return item_type_str.lower() == 'material'

def is_material(
    item_type: Optional[str] = None,
    material_type_id: Optional[int] = None,
) -> bool:
    """
    Determine if a product is a material (filament).

    Detection priority:
    1. item_type == 'material' (explicit, preferred)
    2. material_type_id is not None (legacy filament detection)
    
    Args:
        item_type: The product's item_type field
        material_type_id: The product's material_type_id field
        
    Returns:
        True if the product is a material
    """
    # Priority 1: Explicit item_type='material'
    if is_material_item_type(item_type):
        return True
    
    # Priority 2: Legacy detection via material_type_id
    if material_type_id is not None:
        return True
    
    return False

def get_uom_config(
    item_type: Optional[str] = None,
    material_type_id: Optional[int] = None,
    category_is_filament: bool = False,
    sku: Optional[str] = None,
) -> UOMConfig:
    """
    Get the UOM configuration for a product.

    This is the SINGLE FUNCTION that determines UOM settings.
    All UOM decisions should flow through this function.
    
    Detection priority (most specific to least):
    1. item_type == 'material' (explicit)
    2. item_type == 'supply' AND material_type_id IS NOT NULL (legacy)
    3. category_is_filament == True (category-based)
    4. SKU starts with 'MAT-' or 'FIL-' (SKU-based fallback)
    
    Args:
        item_type: Product's item_type field
        material_type_id: Product's material_type_id field
        category_is_filament: Whether product's category is a filament category
        sku: Product's SKU (for fallback detection)
        
    Returns:
        UOMConfig with appropriate settings
    """
    # Normalize item_type to lowercase string
    item_type_str = None
    if item_type:
        item_type_str = item_type.value if hasattr(item_type, 'value') else str(item_type)
        item_type_str = item_type_str.lower()
    
    # Priority 1: Explicit item_type='material'
    if item_type_str == 'material':
        return MATERIAL_UOM
    
    # Priority 2: Legacy - supply with material_type_id
    if item_type_str == 'supply' and material_type_id is not None:
        return MATERIAL_UOM
    
    # Priority 3: Category-based detection
    if category_is_filament:
        return MATERIAL_UOM
    
    # Priority 4: SKU prefix fallback
    if sku:
        sku_upper = sku.upper()
        if sku_upper.startswith(('MAT-', 'FIL-')):
            return MATERIAL_UOM
    
    return DEFAULT_UOM

def get_uom_config_for_product(product) -> UOMConfig:
    """
    Convenience function to get UOM config directly from a Product model.

    Args:
        product: A Product model instance
        
    Returns:
        UOMConfig with appropriate settings
    """
    return get_uom_config(
        item_type=getattr(product, 'item_type', None),
        material_type_id=getattr(product, 'material_type_id', None),
        sku=getattr(product, 'sku', None),
    )

# =============================================================================

# VALIDATION FUNCTIONS

# =============================================================================

def validate_material_uom(
    unit: Optional[str],
    purchase_uom: Optional[str],
    purchase_factor: Optional[Decimal],
) -> List[str]:
    """
    Validate that a material's UOM configuration is correct.

    Args:
        unit: The product's storage unit
        purchase_uom: The product's purchase UOM
        purchase_factor: The product's purchase factor
        
    Returns:
        List of error messages (empty list = valid)
    """
    errors = []
    
    unit_upper = (unit or '').upper()
    purchase_uom_upper = (purchase_uom or '').upper()
    
    if unit_upper != MATERIAL_UOM.unit:
        errors.append(
            f"Material unit should be '{MATERIAL_UOM.unit}', got '{unit}'"
        )
    
    if purchase_uom_upper != MATERIAL_UOM.purchase_uom:
        errors.append(
            f"Material purchase_uom should be '{MATERIAL_UOM.purchase_uom}', got '{purchase_uom}'"
        )
    
    if purchase_factor != MATERIAL_UOM.purchase_factor:
        errors.append(
            f"Material purchase_factor should be {MATERIAL_UOM.purchase_factor}, got {purchase_factor}"
        )
    
    return errors

def get_material_sku_prefixes() -> tuple:
    """Return valid SKU prefixes for materials."""
    return ('MAT-', 'FIL-')

def get_default_material_sku_prefix() -> str:
    """Return the default SKU prefix for new materials."""
    return 'MAT'
0.2 Create backend/app/core/__init__.py (if it doesn't exist)
python"""Core application configuration and constants."""

## Phase 1: Fix Critical Backend Bugs

These fixes address the immediate causes of UOM bugs.
1.1 Update backend/app/services/inventory_helpers.py
Current code has a bug: It only checks material_type_id, missing items with item_type='material'.
Replace the entire file with:
python"""
Inventory Helper Functions

Utilities for handling material vs. non-material items in the inventory system.

IMPORTANT: This module uses the centralized UOM config. Do not hardcode
material detection logic here - use the functions from uom_config.py
"""
from app.models.product import Product
from app.core.uom_config import (
    is_material as_is_material,
    get_uom_config_for_product,
    MATERIAL_UOM,
)

def is_material(product: Product) -> bool:
    """
    Check if a product is a material/filament.

    Materials are identified by:
    1. item_type == 'material' (explicit, preferred)
    2. material_type_id is not None (legacy filaments)
    
    All materials should use grams (G) as their storage unit.
    
    Args:
        product: Product model instance
    
    Returns:
        True if product is a material (filament), False otherwise
    """
    return _is_material(
        item_type=product.item_type,
        material_type_id=product.material_type_id,
    )

def get_transaction_unit(product: Product) -> str:
    """
    Get the unit to use for inventory transactions.

    - Materials: Always "G" (grams) - from centralized config
    - Other items: Use product.unit (EA, etc.)
    
    Args:
        product: Product model instance
    
    Returns:
        Unit string ("G" for materials, product.unit for others)
    """
    if is_material(product):
        return MATERIAL_UOM.unit  # "G"
    return product.unit or "EA"

def convert_to_transaction_unit(quantity: float, from_unit: str, product: Product) -> float:
    """
    Convert quantity to the transaction unit for a product.

    For materials: Converts to grams using standard conversion factors
    For others: Returns quantity as-is (no conversion)
    
    Args:
        quantity: Quantity in from_unit
        from_unit: Source unit (KG, LB, EA, etc.)
        product: Product model instance
    
    Returns:
        Quantity in transaction unit (G for materials, product.unit for others)
    """
    if not is_material(product):
        # Non-materials: no conversion needed
        return quantity
    
    # Materials: Convert to grams
    from_unit_upper = (from_unit or '').upper().strip()
    
    # Conversion factors to grams
    conversion_to_grams = {
        'G': 1.0,
        'KG': 1000.0,
        'LB': 453.592,
        'OZ': 28.3495,
    }
    
    factor = conversion_to_grams.get(from_unit_upper)
    if factor is None:
        # Unknown unit - log warning and assume grams
        import logging
        logging.warning(
            f"Unknown material unit '{from_unit}' for product {product.sku}, assuming grams"
        )
        return quantity
    
    return quantity * factor

def get_purchase_factor(product: Product) -> float:
    """
    Get the purchase factor for a product.

    The purchase factor converts from purchase_uom to unit.
    For materials: 1000 (1 KG = 1000 G)
    For others: Uses product.purchase_factor or 1
    
    Args:
        product: Product model instance
        
    Returns:
        Purchase factor as float
    """
    if is_material(product):
        return float(MATERIAL_UOM.purchase_factor)
    
    if product.purchase_factor:
        return float(product.purchase_factor)
    
    return 1.0
1.2 Update backend/app/services/material_service.py
Current bug: Missing purchase_factor when creating material products.
Find the create_material_product function (around line 240-280) and update it:
pythondef create_material_product(
    db: Session,
    material_type_code: str,
    color_code: str,
    commit: bool = True
) -> Product:
    """
    Creates a 'material' type Product for a given material and color.

    This function is the single source for creating material products, ensuring
    that a corresponding Inventory record is also created.
    
    UOM Configuration (from centralized config):
    - unit: G (grams) - storage/consumption unit
    - purchase_uom: KG (kilograms) - how vendors sell it
    - purchase_factor: 1000 - conversion factor (1 KG = 1000 G)
    - is_raw_material: True

    Args:
        db: Database session
        material_type_code: The code of the material type (e.g., 'PLA_BASIC')
        color_code: The code of the color (e.g., 'BLK')
        commit: Whether to commit the transaction

    Returns:
        The newly created Product object.
    """
    # Import centralized config
    from app.core.uom_config import MATERIAL_UOM
    
    material_type = get_material_type(db, material_type_code)
    color = get_color(db, color_code)

    # Generate SKU from material and color
    sku = f"MAT-{material_type.code}-{color.code}"

    # Check if product already exists
    existing_product = db.query(Product).filter(Product.sku == sku).first()
    if existing_product:
        return existing_product

    # Create the new product with centralized UOM config
    new_product = Product(
        sku=sku,
        name=f"{material_type.name} - {color.name}",
        description=f"Filament material: {material_type.name} in {color.name}",
        item_type='material',  # NEW: Use explicit material type
        procurement_type='buy',
        unit=MATERIAL_UOM.unit,  # G (from config)
        purchase_uom=MATERIAL_UOM.purchase_uom,  # KG (from config)
        purchase_factor=MATERIAL_UOM.purchase_factor,  # 1000 (from config) - THIS WAS MISSING!
        standard_cost=material_type.base_price_per_kg,  # Cost is $/KG
        is_raw_material=MATERIAL_UOM.is_raw_material,  # True (from config)
        material_type_id=material_type.id,
        color_id=color.id,
        active=True
    )
    db.add(new_product)
    db.flush()  # To get the product ID

    # Ensure an inventory record exists for the new product
    # Get default location
    location = db.query(InventoryLocation).filter(InventoryLocation.code == 'MAIN').first()
    if not location:
        location = InventoryLocation(name="Main Warehouse", code="MAIN", type="warehouse")
        db.add(location)
        db.flush()

    inventory_record = Inventory(
        product_id=new_product.id,
        location_id=location.id,
        on_hand_quantity=0,
        allocated_quantity=0
    )
    db.add(inventory_record)

    if commit:
        db.commit()

    return new_product
Also add the import at the top of the file:
pythonfrom app.models.inventory import Inventory, InventoryLocation

## Phase 2: Update Schema to Add Material Item Type

2.1 Update backend/app/schemas/item.py
Find the ItemType enum (around line 21-26) and add the MATERIAL value:
pythonclass ItemType(str, Enum):
    """Types of items in the system"""
    FINISHED_GOOD = "finished_good"  # Sellable products
    COMPONENT = "component"          # Parts used in assembly
    SUPPLY = "supply"                # Consumables and supplies
    SERVICE = "service"              # Non-physical services
    MATERIAL = "material"            # Raw materials (filament) - auto-configures UOM

## Phase 3: Update Product UOM Service

3.1 Update backend/app/services/product_uom_service.py
Replace the entire file to use centralized config:
python"""
Product UOM Service

Provides validation and auto-configuration for product units of measure.
Uses centralized configuration from app.core.uom_config.

IMPORTANT: All UOM constants come from uom_config.py - do not hardcode here.
"""
from typing import Optional, Tuple
from decimal import Decimal
from sqlalchemy.orm import Session

from app.models.product import Product
from app.models.item_category import ItemCategory
from app.core.uom_config import (
    MATERIAL_UOM,
    DEFAULT_UOM,
    get_uom_config,
    is_material,
    validate_material_uom,
    get_material_sku_prefixes,
)

# Category codes that indicate filament (continuous materials)

FILAMENT_CATEGORY_CODES = {
    'FILAMENT', 'PLA', 'PETG', 'ABS', 'TPU', 'ASA', 'NYLON',
    'PLA_BASIC', 'PLA_MATTE', 'PLA_SILK', 'PLA_SILK_MULTI',
    'PETG_BASIC', 'PETG_HF', 'PETG_CF', 'PETG_TRANSLUCENT',
    'ABS_GF', 'TPU_68D', 'TPU_95A', 'MATERIAL', 'MATERIALS',
}

def is_filament_category(db: Session, category_id: Optional[int]) -> bool:
    """
    Check if a category (or its parent) is a filament category.

    Walks up the category tree to check for filament indicators.
    """
    if not category_id:
        return False
    
    # Walk up the category tree
    category = db.query(ItemCategory).filter(ItemCategory.id == category_id).first()
    while category:
        if category.code and category.code.upper() in FILAMENT_CATEGORY_CODES:
            return True
        if category.parent_id:
            category = db.query(ItemCategory).filter(ItemCategory.id == category.parent_id).first()
        else:
            break
    
    return False

def is_filament_sku(sku: Optional[str]) -> bool:
    """Check if SKU indicates a filament/material product."""
    if not sku:
        return False
    return sku.upper().startswith(get_material_sku_prefixes())

def is_hardware_sku(sku: Optional[str]) -> bool:
    """Check if SKU indicates a hardware product."""
    if not sku:
        return False
    return sku.upper().startswith(('HW-',))

def get_recommended_uoms(
    db: Session,
    sku: Optional[str] = None,
    category_id: Optional[int] = None,
    item_type: Optional[str] = None,
) -> Tuple[str, str, bool, Decimal]:
    """
    Get recommended UOM settings based on SKU, category, and item_type.

    Returns:
        Tuple of (purchase_uom, unit, is_raw_material, purchase_factor)
        
    Detection priority:
    1. item_type == 'material' (explicit)
    2. Category is filament category
    3. SKU starts with material prefix
    """
    # Use centralized config
    uom_config = get_uom_config(
        item_type=item_type,
        category_is_filament=is_filament_category(db, category_id),
        sku=sku,
    )
    
    return (
        uom_config.purchase_uom,
        uom_config.unit,
        uom_config.is_raw_material,
        uom_config.purchase_factor,
    )

def validate_product_uoms(
    db: Session,
    product: Product,
) -> Tuple[bool, Optional[str]]:
    """
    Validate that a product's UOMs are correctly configured.

    Returns:
        Tuple of (is_valid, error_message)
    """
    # Determine if this should be a material
    is_mat = is_material(
        item_type=product.item_type,
        material_type_id=product.material_type_id,
    )
    
    if not is_mat:
        # Also check by SKU and category
        if is_filament_sku(product.sku) or is_filament_category(db, product.category_id):
            is_mat = True
    
    if not is_mat:
        # Not a material, no special validation needed
        return (True, None)
    
    # Validate material UOM configuration
    errors = validate_material_uom(
        unit=product.unit,
        purchase_uom=product.purchase_uom,
        purchase_factor=product.purchase_factor,
    )
    
    # Additional validation: is_raw_material should be True
    if not product.is_raw_material:
        errors.append("Material products should have is_raw_material=True")
    
    if errors:
        return (False, "; ".join(errors))
    
    return (True, None)

def auto_configure_product_uoms(
    db: Session,
    product: Product,
    force: bool = False,
) -> bool:
    """
    Auto-configure a product's UOMs based on detection logic.

    Args:
        db: Database session
        product: Product to configure
        force: If True, overwrite existing values. If False, only set if not already set.
    
    Returns:
        True if changes were made
    """
    purchase_uom, unit, is_raw_material, purchase_factor = get_recommended_uoms(
        db,
        sku=product.sku,
        category_id=product.category_id,
        item_type=product.item_type,
    )
    
    changed = False
    
    # Update purchase_uom
    if force or not product.purchase_uom:
        if product.purchase_uom != purchase_uom:
            product.purchase_uom = purchase_uom
            changed = True
    
    # Update unit
    if force or not product.unit or product.unit == 'EA':
        if product.unit != unit:
            product.unit = unit
            changed = True
    
    # Update purchase_factor
    if force or not product.purchase_factor:
        if product.purchase_factor != purchase_factor:
            product.purchase_factor = purchase_factor
            changed = True
    
    # Update is_raw_material
    if force or not product.is_raw_material:
        if product.is_raw_material != is_raw_material and is_raw_material:
            product.is_raw_material = is_raw_material
            changed = True
    
    return changed

def get_cost_display_info(product: Product) -> dict:
    """
    Get display information for product cost.

    Returns dict with:
        - cost: The effective cost value
        - cost_unit: What the cost is per (e.g., 'KG', 'EA')
        - storage_unit: What inventory is tracked in
        - needs_conversion: Whether cost conversion is needed
    """
    purchase_uom = (product.purchase_uom or product.unit or 'EA').upper()
    storage_unit = (product.unit or 'EA').upper()
    cost = product.standard_cost or product.average_cost or product.last_cost
    
    return {
        'cost': float(cost) if cost else None,
        'cost_unit': purchase_uom,
        'storage_unit': storage_unit,
        'needs_conversion': purchase_uom != storage_unit,
        'cost_display': f"${float(cost):.2f}/{purchase_uom}" if cost else None,
    }

## Phase 4: Update Items API Endpoint

4.1 Update backend/app/api/v1/endpoints/items.py
Make these specific changes:
4.1.1 Remove the duplicated UOM_CONVERSIONS dictionary (around line 40-70).
Delete this entire block:
python# DELETE THIS ENTIRE BLOCK
UOM_CONVERSIONS = {
    'G': {'base': 'KG', 'factor': Decimal('0.001')},
    # ... etc
}
4.1.2 Remove the convert_uom_inline function (around line 75-95).
Delete this entire function.
4.1.3 Add imports at the top of the file:
pythonfrom app.core.uom_config import (
    MATERIAL_UOM,
    get_uom_config,
    is_material,
    get_default_material_sku_prefix,
)
from app.services.uom_service import convert_quantity_safe
4.1.4 Update the create_item function to auto-configure materials:
Find the create_item function and update the item creation logic. After the SKU generation and before creating the Product, add:
<python@router.post>("", response_model=ItemResponse, status_code=201)
async def create_item(
    request: ItemCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Create a new item"""
    # Auto-generate SKU if not provided
    if not request.sku or request.sku.strip() == "":
        # Get item_type as string
        item_type_value = request.item_type.value if hasattr(request.item_type, 'value') else str(request.item_type)

        # Generate SKU based on item type
        item_type_prefix = {
            "finished_good": "FG",
            "component": "COMP",
            "supply": "SUP",
            "service": "SRV",
            "material": get_default_material_sku_prefix(),  # "MAT"
        }.get(item_type_value, "ITM")
        
        # Find the highest existing SKU with this prefix
        existing_skus = db.query(Product.sku).filter(
            Product.sku.like(f"{item_type_prefix}-%")
        ).all()
        
        max_num = 0
        for (sku,) in existing_skus:
            try:
                parts = sku.split("-")
                if len(parts) >= 2:
                    num = int(parts[-1])
                    max_num = max(max_num, num)
            except (ValueError, IndexError):
                pass
        
        new_num = max_num + 1
        request.sku = f"{item_type_prefix}-{new_num:03d}"
    
    # Check for duplicate SKU
    existing = db.query(Product).filter(Product.sku == request.sku.upper()).first()
    if existing:
        raise HTTPException(status_code=400, detail=f"SKU '{request.sku}' already exists")

    # Validate category if provided
    if request.category_id:
        category = db.query(ItemCategory).filter(ItemCategory.id == request.category_id).first()
        if not category:
            raise HTTPException(status_code=400, detail=f"Category {request.category_id} not found")

    # Get item_type value for UOM configuration
    item_type_value = request.item_type.value if hasattr(request.item_type, 'value') else str(request.item_type)
    
    # Auto-configure UOM for materials
    if item_type_value == 'material':
        # Use centralized material config
        final_unit = MATERIAL_UOM.unit  # G
        final_purchase_uom = MATERIAL_UOM.purchase_uom  # KG
        final_purchase_factor = MATERIAL_UOM.purchase_factor  # 1000
        final_is_raw_material = MATERIAL_UOM.is_raw_material  # True
    else:
        # Use provided values or defaults
        final_unit = request.unit or "EA"
        final_purchase_uom = request.purchase_uom or request.unit or "EA"
        final_purchase_factor = request.purchase_factor if hasattr(request, 'purchase_factor') else None
        final_is_raw_material = request.is_raw_material or False

    item = Product(
        sku=request.sku.upper(),
        name=request.name,
        description=request.description,
        unit=final_unit,
        purchase_uom=final_purchase_uom,
        purchase_factor=final_purchase_factor,
        item_type=item_type_value,
        procurement_type=request.procurement_type.value if request.procurement_type else "buy",
        category_id=request.category_id,
        cost_method=request.cost_method.value if request.cost_method else "average",
        standard_cost=request.standard_cost,
        selling_price=request.selling_price,
        weight_oz=request.weight_oz,
        length_in=request.length_in,
        width_in=request.width_in,
        height_in=request.height_in,
        lead_time_days=request.lead_time_days,
        min_order_qty=request.min_order_qty,
        reorder_point=request.reorder_point,
        stocking_policy=request.stocking_policy.value if request.stocking_policy else "on_demand",
        upc=request.upc,
        legacy_sku=request.legacy_sku,
        is_raw_material=final_is_raw_material,
        track_lots=request.track_lots or False,
        track_serials=request.track_serials or False,
        active=True,
    )

    db.add(item)
    db.commit()
    db.refresh(item)

    logger.info(f"Created item: {item.sku}")

    return _build_item_response(item, db)
4.1.5 Update the list_items function to handle material type filtering:
Find the item_type filtering logic (around line 350-380) and update:
python    if item_type:
        if item_type == "filament":
            # Filaments are items with material_type_id (legacy) OR item_type='material'
            query = query.filter(
                or_(
                    Product.material_type_id.isnot(None),
                    Product.item_type == "material"
                )
            )
        elif item_type == "material":
            # Material type - includes both new item_type='material' and legacy filaments
            query = query.filter(
                or_(
                    Product.item_type == "material",
                    Product.material_type_id.isnot(None)
                )
            )
        else:
            query = query.filter(Product.item_type == item_type)
4.1.6 Update the CSV import valid item types:
Find the line where item types are validated in the CSV import (around line 1400) and add "material":
pythonitem_type_map = {
    "simple": "finished_good",
    "variable": "finished_good",
    "finished_good": "finished_good",
    "component": "component",
    "supply": "supply",
    "service": "service",
    "material": "material",      # NEW
    "filament": "material",      # Map filament to material
    "raw_material": "material",  # Map raw_material to material
}
4.1.7 Update the_recalculate_bom_cost function to use centralized conversion:
Find the _recalculate_bom_cost function and update the UOM conversion to use the service:
pythondef_recalculate_bom_cost(bom: BOM, db: Session) -> Decimal:
    """
    Recalculate BOM total cost from component standard_costs.
    """
    from app.services.uom_service import convert_quantity_safe

    total = Decimal("0")

    lines = db.query(BOMLine).filter(BOMLine.bom_id == bom.id).all()

    for line in lines:
        component = db.query(Product).filter(Product.id == line.component_id).first()
        if component:
            component_cost = component.standard_cost or component.average_cost or component.last_cost
            if component_cost:
                qty = line.quantity or Decimal("0")
                scrap = line.scrap_factor or Decimal("0")
                effective_qty = qty * (1 + scrap / 100)

                component_unit = component.unit
                line_unit = line.unit

                if line_unit and component_unit and line_unit.upper() != component_unit.upper():
                    # Use service for conversion
                    converted_qty, success = convert_quantity_safe(
                        db, effective_qty, line_unit, component_unit
                    )
                    if success:
                        total += Decimal(str(component_cost)) * converted_qty
                    else:
                        # Conversion failed, use original qty
                        total += Decimal(str(component_cost)) * effective_qty
                else:
                    total += Decimal(str(component_cost)) * effective_qty

    bom.total_cost = total
    bom.updated_at = datetime.utcnow()

    return total

## Phase 5: Update Purchase Order Receiving

5.1 Update backend/app/api/v1/endpoints/purchase_orders.py
Add import at the top:
pythonfrom app.core.uom_config import get_uom_config_for_product, is_material, MATERIAL_UOM
Find the receive_purchase_order function and update the material detection logic.
Around line 850-950, there's code that determines if a product is a material. Update to use centralized config:
Replace:
python# Check if this is a material (for cost handling)
is_mat = is_material(product)
With:
python# Check if this is a material using centralized detection
from app.core.uom_config import is_material as is_material_check
is_mat = is_material_check(
    item_type=product.item_type,
    material_type_id=product.material_type_id
)
Also update the lot creation condition (around line 939):
python# Create lot for materials - check both item_type and material_type_id
if product.item_type in ('supply', 'component', 'material') or product.material_type_id:

## Phase 6: Update Test Factories

6.1 Update backend/tests/factories.py
Find the create_test_material function and update it:
pythonfrom app.core.uom_config import MATERIAL_UOM

def create_test_material(
    db: Session,
    sku: str = "TEST-MAT-001",
    name: str = "Test Material",
    material_type_id: Optional[int] = None,
    color_id: Optional[int] = None,
    standard_cost: Decimal = Decimal("20.00"),  # $/KG
    on_hand_quantity: Decimal = Decimal("0"),
    **kwargs
) -> Product:
    """
    Create a test material product with correct UOM configuration.

    Uses centralized MATERIAL_UOM config for consistency.
    """
    product = Product(
        sku=sku,
        name=name,
        item_type="material",  # Use explicit material type
        procurement_type="buy",
        unit=MATERIAL_UOM.unit,  # G
        purchase_uom=MATERIAL_UOM.purchase_uom,  # KG
        purchase_factor=MATERIAL_UOM.purchase_factor,  # Decimal('1000')
        is_raw_material=MATERIAL_UOM.is_raw_material,  # True
        standard_cost=standard_cost,
        material_type_id=material_type_id,
        color_id=color_id,
        active=True,
        **kwargs
    )
    db.add(product)
    db.flush()
    
    # Create inventory record if quantity provided
    if on_hand_quantity > 0:
        from app.models.inventory import Inventory, InventoryLocation
        
        location = db.query(InventoryLocation).filter(
            InventoryLocation.code == 'MAIN'
        ).first()
        
        if not location:
            location = InventoryLocation(
                name="Main Warehouse",
                code="MAIN",
                type="warehouse"
            )
            db.add(location)
            db.flush()
        
        inventory = Inventory(
            product_id=product.id,
            location_id=location.id,
            on_hand_quantity=on_hand_quantity,
            allocated_quantity=Decimal("0")
        )
        db.add(inventory)
    
    return product

## Phase 7: Frontend Updates

7.1 Update frontend/src/components/ItemForm.jsx
Find the ITEM_TYPES constant (around line 18-23) and add material:
javascriptconst ITEM_TYPES = [
  { value: "finished_good", label: "Finished Good" },
  { value: "component", label: "Component" },
  { value: "supply", label: "Supply" },
  { value: "service", label: "Service" },
  { value: "material", label: "Material (Filament)" },  // NEW
];
Add a useEffect to auto-configure material UOM (add after other useEffects):
javascript// Auto-configure UOM when item_type changes to 'material'
useEffect(() => {
  if (formData.item_type === 'material' && !isEditMode) {
    setFormData(prev => ({
      ...prev,
      unit: 'G',
      purchase_uom: 'KG',
      purchase_factor: 1000,
      is_raw_material: true,
      procurement_type: 'buy'
    }));
  }
}, [formData.item_type, isEditMode]);
Add a hint below the item_type select (in the JSX):

```jsx
{formData.item_type === 'material' && (
  <p className="text-xs text-blue-400 mt-1">
    ℹ️ Materials auto-configure: Unit=G (grams), Purchase=KG, Factor=1000
  </p>
)}
```

7.2 Update frontend/src/components/ItemWizard.jsx
Find the ITEM_TYPES constant and add material:
javascriptconst ITEM_TYPES = [
  { value: "finished_good", label: "Finished Good", color: "blue", defaultProcurement: "make" },
  { value: "component", label: "Component", color: "purple", defaultProcurement: "buy" },
  { value: "supply", label: "Supply", color: "green", defaultProcurement: "buy" },
  { value: "service", label: "Service", color: "gray", defaultProcurement: "buy" },
  { value: "material", label: "Material (Filament)", color: "orange", defaultProcurement: "buy" },  // NEW
];
Find the SKU prefix generation logic and add material:
javascriptconst skuPrefix =
  item.item_type === "finished_good" ? "FG" :
  item.item_type === "component" ? "COMP" :
  item.item_type === "supply" ? "SUP" :
  item.item_type === "service" ? "SRV" :
  item.item_type === "material" ? "MAT" :  // NEW
  "ITM";
7.3 Update frontend/src/pages/admin/AdminItems.jsx
Find the ITEM_TYPES constant and add material:
javascriptconst ITEM_TYPES = [
  { value: "finished_good", label: "Finished Good", color: "blue" },
  { value: "component", label: "Component", color: "purple" },
  { value: "supply", label: "Supply", color: "green" },
  { value: "service", label: "Service", color: "gray" },
  { value: "material", label: "Material", color: "orange" },  // NEW
];
Find the stats calculation and add materials count:
javascriptconst stats = {
  total: items.length,
  finishedGoods: items.filter((i) => i.item_type === "finished_good").length,
  components: items.filter((i) => i.item_type === "component").length,
  supplies: items.filter((i) => i.item_type === "supply").length,
  services: items.filter((i) => i.item_type === "service").length,
  materials: items.filter((i) => i.item_type === "material" || i.material_type_id).length,  // NEW
};
7.4 Update frontend/src/components/BOMEditor.jsx
Find the default unit logic (around line 290-295) and fix it:
javascript// Set unit based on component type - use G for materials, not KG
const defaultUnit = component.unit ||
  (component.item_type === "material" ? "G" :
   (component.item_type === "supply" && component.material_type_id) ? "G" :  // Legacy filaments
   component.item_type === "supply" ? "EA" :
   "EA");
Also update in the add component section (around line 470):
javascriptonChange={(e) => {
  const selectedId = e.target.value;
  const selected = allComponents.find(
    (c) => c.id === parseInt(selectedId)
  );
  
  // Determine default unit based on type
  let defaultUnit = selected?.unit || "EA";
  if (!selected?.unit) {
    if (selected?.item_type === "material" ||
        (selected?.item_type === "supply" && selected?.material_type_id)) {
      defaultUnit = "G";  // Materials use grams
    }
  }
  
  setNewLine({
    ...newLine,
    component_id: selectedId,
    unit: defaultUnit,
  });
}}
7.5 Update frontend/src/components/purchasing/QuickCreateItemModal.jsx
Find the item_type select and add material option:

```jsx
<select ...>
  <option value="finished_good">Finished Good</option>
  <option value="component">Component</option>
  <option value="supply">Supply</option>
  <option value="service">Service</option>
  <option value="material">Material (Filament)</option>  {/* NEW */}
</select>
```

## Phase 8: Data Migration (Optional but Recommended)

Create an Alembic migration to fix existing data.
8.1 Create migration file
Run: alembic revision -m "fix_material_uom_configuration"
Then edit the generated file:
python"""fix_material_uom_configuration

Revision ID: xxxx
Revises: yyyy
Create Date: 2025-01-xx

This migration fixes UOM configuration for existing material/filament products.
"""
from alembic import op
from decimal import Decimal

# revision identifiers

revision = 'xxxx'
down_revision = 'yyyy'
branch_labels = None
depends_on = None

def upgrade():
    # Fix materials that have material_type_id but wrong UOM config
    # These are legacy filaments that need purchase_factor
    op.execute("""
        UPDATE products
        SET
            purchase_factor = 1000,
            unit = CASE WHEN unit IS NULL OR unit = 'EA' OR unit = 'KG' THEN 'G' ELSE unit END,
            purchase_uom = CASE WHEN purchase_uom IS NULL OR purchase_uom = 'EA' THEN 'KG' ELSE purchase_uom END,
            is_raw_material = TRUE
        WHERE material_type_id IS NOT NULL
        AND (
            purchase_factor IS NULL
            OR purchase_factor != 1000
            OR unit IS NULL
            OR unit != 'G'
        )
    """)

    # Optionally: Migrate legacy supply+material_type_id to item_type='material'
    # Uncomment if you want to standardize on item_type='material'
    # op.execute("""
    #     UPDATE products 
    #     SET item_type = 'material' 
    #     WHERE item_type = 'supply' 
    #     AND material_type_id IS NOT NULL
    # """)

def downgrade():
    # No downgrade - these are data fixes
    pass

## Verification Steps

After implementation, verify with these tests:

### Backend Tests

bashcd backend

### python -m pytest tests/ -v -k "material or uom" --tb=short

Manual API Tests

1. Create a material item:
bashcurl -X POST <http://localhost:8000/api/v1/items> \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "Test PLA Blue", "item_type": "material"}'
Expected response should show:

unit: "G"
purchase_uom: "KG"
is_raw_material: true
sku starting with MAT-

1. Create a purchase order and receive it:

Create PO with 1 KG of material at $20/KG
Receive the PO
Verify inventory shows 1000 G
Verify unit cost is correctly converted

1. Filter items by type:

### bashcurl <http://localhost:8000/api/v1/items?item_type=material>

Should return both new item_type='material' items AND legacy filaments with material_type_id.
Frontend Tests

Go to Admin > Items > Create
Select "Material (Filament)" as type
Verify unit auto-populates to "G"

## Verify hint text appears

Save and verify item is created correctly

File Summary
Files to CREATE:

backend/app/core/uom_config.py
backend/app/core/__init__.py (if doesn't exist)

Files to MODIFY:

backend/app/schemas/item.py
backend/app/services/inventory_helpers.py
backend/app/services/material_service.py
backend/app/services/product_uom_service.py
backend/app/api/v1/endpoints/items.py
backend/app/api/v1/endpoints/purchase_orders.py
backend/tests/factories.py
frontend/src/components/ItemForm.jsx
frontend/src/components/ItemWizard.jsx
frontend/src/pages/admin/AdminItems.jsx

## frontend/src/components/BOMEditor.jsx

frontend/src/components/purchasing/QuickCreateItemModal.jsx

Key Logic Summary

Materials always use: G (storage), KG (purchase), 1000 (factor), $/KG (cost)
Detection priority: item_type='material' > material_type_id > category > SKU prefix
All UOM constants come from uom_config.py - never hardcode elsewhere
Backwards compatible: Legacy filaments (supply + material_type_id) continue to work
Frontend auto-configures when user selects "Material" type
